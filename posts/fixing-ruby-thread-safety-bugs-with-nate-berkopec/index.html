<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Fixing Thread Safety Bugs With Nate Berkopec | hexdevs</title><meta name=keywords content="Ruby on Rails,Ruby,Software Development,Open Source"><meta name=description content="Can you tell if a Ruby gem is really thread-safe or not? And how do you fix a seemingly thread-safety issue that can be something else entirely?"><meta name=author content="Stefanni Brasil, Thiago Araujo"><link rel=canonical href=https://www.hexdevs.com/posts/fixing-ruby-thread-safety-bugs-with-nate-berkopec/><link crossorigin=anonymous href=/assets/css/stylesheet.c273a41b2e787506844fd09d3ce6881106219496a4585e85de47562c4360a85f.css integrity="sha256-wnOkGy54dQaET9CdPOaIEQYhlJakWF6F3kdWLENgqF8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.hexdevs.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.hexdevs.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.hexdevs.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.hexdevs.com/apple-touch-icon.png><link rel=mask-icon href=https://www.hexdevs.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-205465720-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="Fixing Thread Safety Bugs With Nate Berkopec"><meta property="og:description" content="Can you tell if a Ruby gem is really thread-safe or not? And how do you fix a seemingly thread-safety issue that can be something else entirely?"><meta property="og:type" content="article"><meta property="og:url" content="https://www.hexdevs.com/posts/fixing-ruby-thread-safety-bugs-with-nate-berkopec/"><meta property="og:image" content="https://www.hexdevs.com/images/posts/hexdevs-podcast-fixing-a-ruby-thread-safety-bug-with-nate-berkopec.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-03T21:06:49-07:00"><meta property="article:modified_time" content="2023-04-04T08:11:20-07:00"><meta property="og:site_name" content="hexdevs | Take control of your Developer career"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.hexdevs.com/images/posts/hexdevs-podcast-fixing-a-ruby-thread-safety-bug-with-nate-berkopec.png"><meta name=twitter:title content="Fixing Thread Safety Bugs With Nate Berkopec"><meta name=twitter:description content="Can you tell if a Ruby gem is really thread-safe or not? And how do you fix a seemingly thread-safety issue that can be something else entirely?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.hexdevs.com/posts/"},{"@type":"ListItem","position":2,"name":"Fixing Thread Safety Bugs With Nate Berkopec","item":"https://www.hexdevs.com/posts/fixing-ruby-thread-safety-bugs-with-nate-berkopec/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Fixing Thread Safety Bugs With Nate Berkopec","name":"Fixing Thread Safety Bugs With Nate Berkopec","description":"Can you tell if a Ruby gem is really thread-safe or not? And how do you fix a seemingly thread-safety issue that can be something else entirely?","keywords":["Ruby on Rails","Ruby","Software Development","Open Source"],"articleBody":"Can you tell if a Ruby gem is really thread-safe or not? And how do you fix a seemingly thread-safety issue that can be something else entirely?\nWe had no idea. So we asked Nate Berkopec to help us. Nate is an expert in Ruby performance.\nThe verdict: nuking all shared global mutable state in your Ruby code is a bad idea if you don’t know what you’re doing!\nListen to this episode to learn:\nHow and why faker-ruby became thread-unsafe, especially for Puma users Questions to ask yourself when trying to debug thread-safety issues Shared global mutable state is not always the villain, and is not the source of all thread-safety issues Nate’s “watch-out” list of things that can cause undesired behavior when running multi-threaded Ruby applications: Constants, Class Variables, and Rack Middleware. Apple Podcasts | Spotify\nAbout Nate Nate Berkopec runs Speedshop, a software performance company specializing in Ruby. He’s also the maintainer of Puma, the popular Ruby webserver.\nEpisode Links Get to Senior Podcast Interview with Nate Berkopec Nate Berkopec’s Website The Complete Guide to Rails Performance Sidekiq in Practice faker-ruby Bug Report mini-test parallelize_me! rack-freeze connection pool Rails Bug Report Reproduction Scripts Thanks Valentino Stoll, nfstern02, and Gregg P for sponsoring hexdevs!\nEnjoy!\nTranscript [00:00:00] Stefanni: Hey friends, Stefanni here. Welcome back to another hexdevs episode. Before we go to the episode, we want to thank Nate Berkopec for joining us on this episode about building tread-safe Ruby Code. As some of you might know, we help out at Faker Ruby, and we had an open issue that was related to thread-safety.\n[00:00:28] Stefanni: And we were not quite sure how to fix that bug. So we sent a message to Nate and he kindly accepted the invite. And not only did he help us understand the issue, how to fix it, but he also gave us a lesson on building tread safe ruby code. Something else that we want to share is that this episode, and actually all of our episodes are sponsored by Get to Senior a program that we developed to help experience to Ruby developers take their careers to the next level.\n[00:01:05] Stefanni: And we also have our Git Hub sponsor page. We have two sponsor: Valentino Stoll and Gregg P who have been supporting us. So thank you. And if you, dear Listener, wants to sponsor our work, go to hexdevs.com/get-to-senior or to our get GitHub page to see our sponsor page.\n[00:01:35] Thiago: This is the hexdevs podcast. I’m Thiago.\n[00:01:38] Thiago: And I’m Stefanni.\n[00:01:39] Thiago: Today our guest is Nate Berkopec. Nate makes Rails apps go faster. He’s an expert in Ruby on Rails performance. And he runs a company called Speed Shop, a software performance company specializing in Ruby. He’s the maintainer of Puma, one of the most popular Ruby Web servers out there.\n[00:02:00] Thiago: And he is also the author of the book, the Complete Guide to Ruby on Rails Performance. Thank you so much for joining us, Nate.\n[00:02:06] Nate Berkopec: Hey, thank you very much.\n[00:02:08] Stefanni: Yeah, we just gave Nate some homework to do. We sent him an email.\n[00:02:16] Nate Berkopec: Yeah. What the heck, man? I thought this was a podcast, not like a class. I had to go take,\n[00:02:24] Stefanni: Well, we had a, an issue that was opened on faker not being thread safe. So we didn’t know exactly what to do, how to solve the issue, and we thought it would be a great opportunity to bring Nate, who’s an expert in all of that, to talk more about why faker is not tread safe. And then we could also use this example to understand more how to build thread safe Ruby apps.\n[00:02:59] Stefanni: So thank you so much Nate. And sorry to give you homework.\n[00:03:05] Stefanni: Yeah. So I would like to get started with a heads up about what caught your attention about the issue, why. Is faker not thread-safe?\n[00:03:18] Nate Berkopec: Yeah. So you, you brought me in, uh, and sent me this link to this report. So this was actually after you thought you had fixed a threadsafety issue on faker and so.\n[00:03:33] Nate Berkopec: Basically in faker. So if you’re not familiar with faker, faker is like this extremely commonly used gem for, uh, generating fake data, usually in tests. So you can like, ask for last names. First names, like all, it’s like anything you can think of, faker can pretty much generate a random version of it, right?\n[00:03:55] Nate Berkopec: Mm-hmm. So, Faker also works with locales. So you can have, you know, Japanese data, English data, whatever. Right? So you need to tell it what locale it, it, it’s gonna generate that data for. So there is a setting and that, uh, locale setting, uh, I think has always been, I don’t think this was changed ever. ‘Faker::conf.locale =’. Okay, so that was how you said it. You said that to a, a symbol, I believe you had said it to, you know, en-GB or, or JA or whatever your, your locale is. So there was a, a PR for two included in 2.23, which changed how this worked. And originally, and this was your PR Tiago. The, the PR that I’m about to describe that change, or is it not?\n[00:04:53] Thiago: No, I just approved it.\n[00:04:55] Nate Berkopec: Oh, you just approved it. Okay.\n[00:04:56] Thiago: I did the review and then I’m pretty sure someone else worked on that. Yeah. Oh yeah, it was someone else, but I gave my thumbs up.\n[00:05:04] Nate Berkopec: It’s still your fault. I see. I can, yeah, for sure. Oh, everybody’s fault.\n[00:05:09] Nate Berkopec: Blame the reviewer. Um, so the way that this originally worked was faker config. The module had a, uh, locale. Class variable. So you would set the class variable with locale equals, and you would read it with locale, right? So that’s works. That’s fine. You know, it means that all threads and everything, like if you create a new thread, it’s still gonna read that same value, right?\n[00:05:41] Nate Berkopec: So that, that all works. But, If more than one thread tries to write that value, we start to have problems. Right? So somebody basically made an issue that was like, I use faker in QA. And in QA we’re sending different requests that have different locales. And so the faker. Data, uh, faker is like setting the locale in one thread and then being that a different thread is reading that locale, which has now been overwritten and we don’t want that to happen.\n[00:06:13] Nate Berkopec: So basically the request was that faker should be thread safe. But to to, to rephrase this as more of like a story, the desired behavior is, and you can correct me, this is what I’m a little unclear on, so you can, you can correct me if I’m wrong about this. I think the desired behavior. Is that we should set a default locale, uh, in a, in configuration, like when we start the app.\n[00:06:38] Nate Berkopec: And if we don’t say anything else, this will, this will be the default locale, and then threads should be able to, in a thread safe way, change the locale on a per thread basis. Okay, so you could, you know, if this, if this was, if, if this feature was available, you could, in Puma or any other multi-threaded web server, you could set the locale in a maybe rack middleware or something, I don’t know, like in a before act in a around action in Rails, you would change the locale in faker and then do whatever work you wanted to do, you know, run the rest of the action and.\n[00:07:16] Nate Berkopec: In an ensure block, you could say, set the locale back to what it was before. And um, that would be how you could change that locale. And then you, then you could have like per request locales in a thread-safe way. That. Is that, is that correct? That sounds, that sounded like the desired behavior to me.\n[00:07:32] Thiago: Yeah, that’s the desired behavior. I think we had that before, but it wasn’t tread safe. And then someone wanted to have different threats and not have one overriding the locale on the other tread, and then that was fixed. But then the other person say, Hey, but then you fix my set up now where I run this, I guess in production, I think. Mm-hmm.\n[00:07:53] Thiago: When someone else runs it in production. And now if I use faker in production and I set the locale, It only exists like in one of the requests and then the others don’t, don’t see that anymore. And so it’s kind of like one fix broke someone else’s setup, and then we have to fix both things now.\n[00:08:13] Nate Berkopec: Right. So the, the, the change that was made to try to implement this story was that, uh, locale is no longer just, uh, an at a class attribute. Uh, class, uh, instance class variable. It is a, uh, it sets thread dot current, uh, open bracket, faker config locale, close bracket. And we’re re so we’re, we’re writing, writing and reading thread dot current. Some thread, well, we thought it was a thread variable, and then you, you know, you learn later in the issue is people read the docs.\n[00:08:52] Nate Berkopec: It’s actually fiber local. So that was the change. The instance, the the locale instance, uh, I keep saying instance, it’s not an in class instance variable. It’s a class variable. That class variable locale was removed, completely removed. And there’s some other stuff in here, which I actually haven’t looked at there.\n[00:09:08] Nate Berkopec: You have some other like thread dot current use. Like you, you’ve removed basically several class variables replace them with thread dot current is kind of the theme here. Uh, local, like this local setting is kinda the one I’m just going to talk about it cause it’s the one I looked at and it’s, it’s a good example of everything else here.\n[00:09:26] Nate Berkopec: So then the bug report comes in and per this person’s like this broke something else for me. So, uh, you set up a Rails app in Puma or other threaded web server, you set faker dot conf, faker config dot locale, and Initializer make a request. And then you get the fake data for the default locale for faker, which is en, so the, the faker config dot local setting broke for all Puma users using more than one thread.\n[00:09:58] Nate Berkopec: Um, or actually I think it should be any threadat all. So basically it broke it for Puma completely. So let’s talk about why that happened. Cause I think if you understand why this happened, then like the fix here becomes more obvious. How Puma works. So Puma, when it starts up, it has one process and one thread to when it starts, uh, when it starts itself.\n[00:10:23] Nate Berkopec: And depending on the, uh, mode you have it set to, it may or may not start other processes. But the important thing here is that when Puma processes requests, it sends the request into what we call the um, Our thread pool, which act has a different name? Uh, in pool? No, I guess we just call it the thread pool.\n[00:10:45] Nate Berkopec: Yeah. So it’s the puma thread pool. And, um, that thread pool has anywhere from one to X number of threads where, you know, you set it to whatever you want. So the application request is always processed in a different thread than the thread that Puma was started with. So we. Start the Puma server. We initialize your application, run all the initializers, and then we create the threads for the thread pool.\n[00:11:17] Nate Berkopec: Okay? So that timing is important here because the initializer is run before we create the app, uh, app application threads that, that actually run the, the application requests. So that faker config dot locale is called. Before those, uh, thread pool threads are created, behavior of thread dot current and, uh, sorry, not thread dot current, but the, this is the bracket method.\n[00:11:46] Nate Berkopec: On, on a thread instance, you, uh, instance method, uh, uh, on a thread you could say. So this is accessing thread. No fiber local variables as, as, uh, the documentation points out. So, um, in case you don’t know, all threads have fibers. Fibers are lower level concurrency unit than a thread. So, um, all processes have at least one thread, and all threads have at least one fiber in Ruby.\n[00:12:14] Nate Berkopec: Okay? So some puma doesn’t do this and, uh, your application might create new threads, but, uh, Create new fibers, I should say. But Puma doesn’t actually create new fibers. So for our purposes in this conversation, it’s, it’s, uh, there are no like a thread, it is a thread, uh, variable because there’s, we don’t have, we don’t have multiple fibers here.\n[00:12:37] Nate Berkopec: So, so the thing is, is like when you create these, these fiber local variables with, uh, the bracket method, they’re not inherited. So there’s a really great reproduction in this issue. Um, when you scroll down a bit where someone made like the minimally, the minimally, uh, required reproduction. And all they did was set the fiber, uh, in the current thread, set the, uh, faker locale, then create a new thread inside of that thread, set it again, and then try to read what that was.\n[00:13:08] Nate Berkopec: And, uh, it was, it reproduced the bug in 10 lines of code. Really, really, first of all, as an open source maintainer. That’s exactly what we wanna read, right? We wanna read the 10 line reproduction. It’s. So good job to that person that wrote that. So these, these, these variables are not inherited. So like Puma creates the, the, uh, thread pool to run your, like the threads that actually run the app.\n[00:13:31] Nate Berkopec: And now this locale fiber variable is no longer set. So it goes back to the default value of, of English. So that was the, that was the source. Of the bug here. So does that all, does that all make sense? I’ve been talking a lot now. I’m, I’m done talking.\n[00:13:49] Thiago: Yeah, for sure. That makes a lot of sense.\n[00:13:52] Stefanni: Mm-hmm. Yeah. That, that was Matheus, uh, he has been helping a lot with, with this issue, like I am learning.\n[00:14:04] Thiago: Yeah. I’m curious to know about, because you mentioned that the fiber local variable is not inherited. Right. The other threads. Mm-hmm. But then if we talk about the class variable, right? If I said that class variable on the initializer right, it would be available to all the other threads. Is that Yes. How it works?\n[00:14:29] Nate Berkopec: Yes. Yep. And this is like, uh, this is kind of the, uh, to me, like the, uh, fine grained part of this issue. When it comes to thread safety, it’s just like people are like, okay, we gotta get rid of all shared mutable, state shared mutable state is bad, get rid of it. And that’s like what the PR did, right?\n[00:14:51] Nate Berkopec: Like it nuked the shared mutable state. No more class variables don’t do it. But like you actually do want shared mutable state. In this story, like you want to be able to change the locale for all threads at a particular point in time, right? You want to do that during initialization when there aren’t, when, when you know there aren’t multiple threads, probably trying to read this value and do stuff with it.\n[00:15:21] Nate Berkopec: Like there’s not, like you, you, you wanna do that during a time when it’s probably safe to do it and then later you want the, uh, private state you want thread private state, right? So it’s kind of like a, uh, a little bit complicated there, where like, you want both things, right? Like you want to be able to override this value for all threads.\n[00:15:42] Nate Berkopec: You just wanna be able to do it at a particular time. Um, so the original PR was, uh, thread safe, but just also didn’t work. So you, you, you gained thread safety while breaking the feature. Yeah.\n[00:15:56] Thiago: Yeah. It’s interesting that. Maybe threadsafety is not always the, the goal. Depending on your feature, maybe you want to be able to share state between threats and maybe if you want to mutate the global state, then you have to worry about thread safety and how you, you would approach that.\n[00:16:17] Thiago: But in this case, you broke the feature by doing that. Right. Which is kind of interesting.\n[00:16:23] Nate Berkopec: Yes, and, and sometimes it’s also a little bit complicated here because. You, you also don’t, in this story, right, you don’t actually really care about the thread safety of setting this locale for all threads. Like you could write this in such a way that, like, the class variable is, is that access and, and reading is thread safe.\n[00:16:51] Nate Berkopec: So like we could use, um, something from concurrent Ruby, for example. It’s a library, a ruby gem that’s used in Rails. And, um, we could set this up so that it’s thread safe to change the locale for all threads, but you don’t really actually care about that because the only time you’re gonna do that is during app initialization.\n[00:17:11] Nate Berkopec: And so, or we could write our own thing with a mutex or whatever to do this, but. You don’t really actually care about the thread safety there, because that happens during initialization where, where there’s only one thread running anyway. So like you could add that to like, you know, check all your thread safety boxes here.\n[00:17:25] Nate Berkopec: But what you really wanted was like private thread state. Like you want to be able to change this value on a per thread basis and not have, not have it affect other threats. Okay. So that’s, To me that’s like a little bit different than thread safety. There’s a, there’s a thread safe way to, to implement this that would still not satisfy the story if we just took the original behavior of the locale class variable and made that access, um, thread safe.\n[00:17:57] Nate Berkopec: What would happen is, is every, every request would change the locale for all other running requests. So like in the middle of a, a halfway through a rendering a response, the faker locale could be changing because other threads are changing. That locale value that you don’t want that, right? Like you don’t want global state, you want per thread state.\n[00:18:18] Nate Berkopec: So like threadsafety is more complicated than just it is thread-safe or not be depending on what, uh, behavior you desire.\n[00:18:26] Stefanni: Yeah, and I also think it’s really easy to. Create those bugs because I don’t think most of us are aware of those details.\n[00:18:39] Nate Berkopec: Um, I think in general, this doesn’t happen in application development because most of this. It’s just like very uncommon to need to write or need to use class variables, for example. So the common sources of of thread safety issues, generally you don’t reach for these like tools that cause these problems in application development, but it does happen all the time in library development. So the most common causes of thread safety issues are class variables. Global variables, which used to be a thing that people did, but I don’t know, mostly people don’t even reach for them anymore and just use constants. Um, constants and uh, rack middleware. So those three things. Of those three things, really, constants is the only thing I see people making mistakes with in application development.\n[00:19:34] Nate Berkopec: But when you’re doing libraries, class variables and in rack middleware, it’s very common to have those, those things. And so you can really. You need to know more about threadsafety when you’re, when you’re writing libraries, I think, than, than writing rails applications, for example. Mm-hmm.\n[00:19:49] Thiago: For sure. I’m curious about the cases you mentioned about like constants, that being a problem. Is that because people try to modify, uh, the value of a constant Yes. At front time?\n[00:20:03] Nate Berkopec: Yeah, exactly. Like, um, setting a constant to like a collection, like a, an array or. Those accesses are not, uh, thread safe. Even, uh, Samuel Williams, the maintainer of, of uh, uh, Falcon, the web server has, has also had this demo where he’s shown that hash access is not, uh, thread safe in hash.\n[00:20:26] Nate Berkopec: Just half hash access is in writing is not thread safe in new, you can even like corrupt the hash, uh, end up with all these crazy behaviors. So yeah, setting constants to collections. And then modifying those collections. So there, there was like a trend, uh, I don’t know, like two years ago, no more than that, I don’t know, four or five years ago to like freeze constants.\n[00:20:50] Nate Berkopec: And we used to do this mostly as a memory saving measure. So like when you freeze an object, Ruby internally allows everybody, everyone that uses that constant can like point to the same object. So we used to like just put a lot of things in constants and freeze them. Uh, now there’s like this Rubocop rule that tells you to freeze everything you put into a constant.\n[00:21:10] Nate Berkopec: And freezing is nice from a memory usage perspective, but it’s even better from a, from a, uh, thread safety perspective because now you get an error, right? If someone tries to modify the object, the, you can still get these problems though with freezing because you can satisfy the rubocop rule. By calling freeze on an array inside of a constant.\n[00:21:32] Nate Berkopec: But if you have a array inside of that array, rubocop won’t say anything. And you still have a threadsafety issue because you’re modifying this unfrozen array inside of the constant. So anything that’s accessible from that constant really can, can lead to a threadsafety issue. So I, I think I see that issue sometimes in app development where people create, um, caches that they want to use. That’s kind of the most common thing is they put a cache inside of a constant and then they end up with a threadsafety issue there. Or the other one I see is, uh, database connections. So if you put a database connection inside of a, a constant, for example, if you just like capital Redis equals redis.new, the issue you’re gonna get there. Everybody accessing that con, accessing that constant is getting the same exact database connection.\n[00:22:21] Nate Berkopec: So if you have two threads accessing the same database connection, you can end up with issues where one thread gets the response for another thread. Um, so you don’t wanna do that and uh, there’s like a lot of gems that help you with this.\n[00:22:34] Nate Berkopec: But basically you need to set it up so that each thread is getting its own connection out of the, uh, connection pool. Um, so those are the most common ones I see in day-to-day app.\n[00:22:44] Thiago: That’s interesting. A good rule of thumb, maybe if you’re working with constants and you’re trying to do something weird or adding some hashes or arrays to the constant, you gotta be careful what you’re doing.\n[00:22:59] Thiago: Yeah. Or a database connection. Yeah. Cool. Mm-hmm.\n[00:23:04] Stefanni: And, and like since you are talking about those common. Things that you see happening in, in development, um, is there something that we as developers could change how we see? Things when we are implementing them. Like how can we start paying more attention to, to those potential thread, safe, uh, issues?\n[00:23:33] Stefanni: Because like you mentioned, it’s not something that we do it every day, for example. Nowadays, I think it’s more common for us to know, oh, this is gonna have a, any plus one query or something like that. So how can we start changing our, our ways of working to. start identifying, those issues. Yeah.\n[00:23:53] Nate Berkopec: My biggest, um, recommendation is always to make your test multi-threaded.\n[00:24:00] Nate Berkopec: So, uh, if you are using Minit test, um, you can run each test inside of its own thread. It’s called mini test. Oh man. Now I’m gonna forget, uh, let me get this mini test cause. Yeah, parallelize is what it’s called. So, um, if you require mini tests slash parallel on a test, uh, or no, include it. Uh, now I’m, I’m not gonna remember it, but look it up.\n[00:24:30] Nate Berkopec: Um, but yeah, you could, you can set up mini tests so it runs each test in a different threat. So that covers your unit tests and makes all your unit tests multi-threading. Um, so if you’re just running minit tests, uh, I suggest turning that. If you’re using RSpec, you’re outta luck. Sorry. Uh, RSpec isn’t multi-threaded, never will be.\n[00:24:50] Nate Berkopec: So you’re stuck. Uh, your only option for multi-threaded tests is to convert them to mini-test. Um, so, you know, good luck.\n[00:24:59] Stefanni: Oh, I was gonna say, okay. What about RSpec? Yeah.\n[00:25:03] Nate Berkopec: Uh, for integration and system tests, so, System tests start a puma server or integration test. Can, you know, you can set up to do whatever you want, right?\n[00:25:15] Nate Berkopec: But you should set up your integration test to set up to start a Puma server and run that puma server with multiple threats. So that will also potentially flush out, uh, threading bugs. Now this is also gonna make your, your test suite less stable like you can. Make a threading bug, usually you can’t cause it like a hundred percent of the time, so you’re gonna start getting flakes probably where they’re caused by threads.\n[00:25:44] Nate Berkopec: Like we, you can’t just like write a test that’s like always triggers a, the thread bug most of the time. So, um, it will probably make your test less stable, but like, you know, that’s, that’s kind of the price you’re gonna pay here. That to me is like, the best possible thing is make your test multi-threaded.\n[00:26:01] Nate Berkopec: So you are actually testing, uh, thread safety. Second thing is like all you can really do is look for those three different sources of, of threading bugs that I talked about. Anytime you’re writing your own rack middleware. So the, the, the threadsafety issue here is that, um, there is only one rack middleware stack for, for an application, right?\n[00:26:25] Nate Berkopec: So, The objects that are created in for, to that actually run your rack middleware, there’s only one of those for every application, um, or every, you know, uh, process. So your application runs in different threads, but they’re all using the same rack middleware objects. So if you have an instance variable inside of a rack middleware, you can end up with a thread safety issue.\n[00:26:50] Nate Berkopec: The fix is actually really easy. There is a, uh, middleware. Freezer that, uh, uh, Samuel Williams wrote called Rack dash Freeze, and. It basically ensures that your rack middleware are, are thread safe by freezing all of your instance variables. Um, and so you can’t possibly cause a problem and it’ll blow up if you try to do thread unsafe things.\n[00:27:18] Nate Berkopec: So take a look at that. For rack middleware, for constants, I think probably everybody should audit constants, created and Initializers, um, for this issue that I talked about. Basically look, make sure you know what you’re putting into constants, uh, is not a collection that’s going to be modified and is not, uh, you know, just a straight up database connection.\n[00:27:43] Nate Berkopec: There’s for database connections, there’s a gem called Connection pool. This is, uh, I think still maintained by Mike Perham. Yeah, so Mike wrote it. I think he wrote it originally anyway, but it’s mper. From Sidekiq, M P M P E R H A M slash connection underscore pool. This is like a generic connection pooler that works with any, uh, underlying database connection gem.\n[00:28:07] Nate Berkopec: So you can get thread safe connection pools that will work with, um, with threads. So you would assign that to a constant instead of, uh, just like redis.new. And then for class variables, those are a little bit easier because hopefully you can just find the at, at like the, at looking for the @@ is like, you know, control F your code base for that.\n[00:28:30] Nate Berkopec: But, um, you and the original, uh, PR actually you had class inherits from self and then it was at locale equals. So like, since you can always do that, it’s kind of hard to like just grep through a code base for class variable. Um, but uh, if you see a file that has a class variable in it, you know, that is shared global mutable states, so you know, it’s only thread unsafe when it, someone tries to write to it from multiple threads.\n[00:28:59] Nate Berkopec: So just because these exist doesn’t mean I think that you should be replacing them all the time. Often, like one thing that, uh, happens is. Someone needs to write a value to a, uh, class variable, and then multiple threads want to read that value. If the writer method, if every thread will just write the same thing.\n[00:29:26] Nate Berkopec: To the class variable, like initialize, like a default value, and then everybody reads the same value after that. That’s not really a thread safety issue because every thread is trying to write the same value, right? So it doesn’t, it doesn’t matter that they could possibly access the, the, the thread ver uh, variable at the sa, the class variable at the same time, because they’re gonna try to write the same thing.\n[00:29:46] Nate Berkopec: So who cares. So it’s like there can be shared global state without there being a thread safety issue, but I think you have to be aware every time you see a class variable or class instance variable that, um, What, think about what, what is trying to write to this and when is it trying to write to this and could there possibly be an issue there?\n[00:30:06] Stefanni: Yeah. I like the questions to ask before you go out there and try to replace everything.\n[00:30:14] Nate Berkopec: Because, because this is complicated, right? Like Yeah. Especially with class variables. Um, you know, writing the mutex dot synchronized stuff, like you’ve probably never written anything with mutex before. You know, pulling something out of concurrent ruby that you’ve never used before and using like a, a data structure out of concurrent Ruby, like, it’s not the easiest thing in the world.\n[00:30:35] Nate Berkopec: So, um, you know, definitely try to avoid it if you can. Um, so yeah, I mean, and people smarter than all of us have done that and then made a mistake anyway, so yeah, it’s, uh, it’s not easy stuff.\n[00:30:50] Thiago: Maybe one thing that exacerbates the problem is that we are very used to. Thinking in Ruby, it’s just like, it’s just one tread and you don’t have to use other treads or anything like that cuz compared to maybe other languages, when we say, oh, in Java, be careful with static variables and things like that.\n[00:31:11] Thiago: But in Ruby, We don’t talk about that a lot, uh, about concurrency. At least, at least in rails. Like it’s just, you don’t have to worry too much about that request is one thread and you don’t have to worry about those things. Yeah. But then when you run into those weird. Bugs, you’re not sure what to do. You just, you just think, oh, I don’t know what that is.\n[00:31:34] Thiago: I don’t, I have no idea why this is happening. But if you try again, you, you’re not gonna have the problem. And so I’m curious about what kind, what kind of things people can do so that when they run into a weird problem, they came, they can point and say, oh, maybe this is a thread safety bug instead of something else.\n[00:31:55] Thiago: So maybe like some strategies or some. Some characteristics. Oh, it’s pretty soft books.\n[00:32:01] Nate Berkopec: It’s pretty easy. Yeah. Like if, if every time I hear, uh, oh one request, no, the request A got the response for request B. So every time I hear like, oh, someone is getting someone else’s responses. And that’s obviously a security issue, right?\n[00:32:22] Nate Berkopec: That’s always, that’s, that’s kind of how this usually comes up is like, oh no, somebody got authorized to someone else. Account because they got someone else’s cookie header, something like that. Right? So anytime I hear, uh, one user A got the response for user B, it’s like thread safety issue immediately.\n[00:32:39] Nate Berkopec: So that, that’s probably the most common one at the application level that I, that I hear about the faker issue specifically. I think maybe you, we kind of all knew because it was like, oh, it was this change. Or like someone realized it was only in Puma. I guess that’s the other, yeah, if it, if it, if switching to unicorn fixes the issue, then you know it’s a threadsafety issue.\n[00:33:02] Nate Berkopec: Right. So, um, cuz in unicorn you don’t even have, there’s no, um, like for example, so I talked about how Puma starts essentially even in the, in the, in the simplest case, it has to start two threads. It has the thread that starts Puma and boots your app, and then the thread that actually runs the application.\n[00:33:21] Nate Berkopec: Right. Technically we’re running your application single-threaded there. Like the actual, uh, every request that comes in to that puma process will always be processed by the same thread. So yes, like it technically is single threaded, but we kind of have this like thread issue, right? With faker even in that scenario because that fiber local variable was not inherited.\n[00:33:48] Nate Berkopec: If moving to Puma breaks the fix, breaks the issue and, and getting off of it fixes it, then you know you have a thread safety issue. Um, but yeah, I think generally like any issue where state is kind of correct for one person but not correct for someone else, and it’s flaky and random, uh, then the, your, your thread safety issue, spider sense should be t.\n[00:34:17] Thiago: Yeah. It’s not Puma’s fault either. It’s just the way Yeah.\n[00:34:21] Nate Berkopec: I mean, it’s your fault threat. Puma’s thread safe. You’re not, so it wasn’t me, man. Yeah,\n[00:34:31] Stefanni: yeah. That was, that was a hard one. And we were like, I think we should ask for someone who knows how to fix this issue. Yeah. Cause we, we were not sure and. I think it’s also, it’s something that I want to see more is people say, uh, well, developers saying that they don’t know things right, and they ask for help.\n[00:34:55] Stefanni: So I thought this would be a, a good way to, to do that.\n[00:35:03] Nate Berkopec: Yeah, and like when I started maintaining Puma, I knew nothing. So like mm-hmm. In 2016 when Evan Phoenix, the original author, like, asked me to start maintaining Puma, like I didn’t know anything about threads, thread safety, or all the other like kind of specific. Things that Puma needs to run. Like, um, knowing about sockets, TCP, UDP, like the f the deep specifics of HTP, um, C extensions.\n[00:35:36] Nate Berkopec: Like, I didn’t know any of that when I started maintaining Puma. And, uh, now I, I know a lot more, but um, when I started I didn’t know anything. So like, we all start not knowing anything. So, um, you know, we are, we every one that you ask a question about thread-safety or whatever. At one point, they didn’t know the answer to that either.\n[00:35:56] Nate Berkopec: So yeah, I don’t think you should feel, uh, intimidated about asking, uh, asking questions like that.\n[00:36:02] Thiago: And it’s also a cool opportunity for contributors. So for example, Matheus who’s. Taking a look at that issue, he said, oh, I don’t know anything about threads but I’ll try to learn something. And then he learn a couple of things and shared.\n[00:36:19] Thiago: And so it’s just a nice way to, to learn more because. You don’t really have to know before you get started on an issue. And then eventually if you continue working on that, you, you’re gonna figure it out and then we can have nice conversations about that. It’s kinda cool. Yeah.\n[00:36:36] Nate Berkopec: Yep. And I think, um, one thing that, I’ll bring it up again that Matheus did that was just like really important for that was to get the minimal reproducing case.\n[00:36:46] Nate Berkopec: So when he had that 10 line example that reproduced the issue. That’s so important for learning because then you have this little experiment that you can, that you can try things on. So you can say, oh, if I change this over here, does that, how does that change the behavior? In my, in my example, um, if you don’t have the minimal reproducible example, it’s much more difficult to to learn because you don’t have a little tool that you can change things on and see what happens.\n[00:37:11] Nate Berkopec: So getting to that minimal example was so important, I think for. For where he went and the rest of the issue. So, um, if I have any advice with that is to like do to, to emulate that behavior to, you know, find, try to try to get to the 10 line example that reproduces the problem.\n[00:37:29] Stefanni: Yeah, I love that. It’s, it’s a very underrated way to get started.\n[00:37:37] Stefanni: We’ve not only contributing to open source, but I think almost anything related to developmental, let’s say. Because you, you get to just try. You’re not trying to fix anything. You’re just trying to find what is going on. And you learn a lot about things\n[00:37:53] Nate Berkopec: in Puma, on GitHub, uh, we have a needs repro label, uh, as a needs reproduction, and I put that on any issue where the original poster has not provided a similarly simple example that can just be run and, and uh, and reproduce it.\n[00:38:13] Nate Berkopec: Um, in Puma, if you’d like to contribute. Um, that’s one way to do it is you go to the needs repro label and just try to reproduce people’s issues. And I can tell you as a maintainer, it’s also helpful if you can’t reproduce it and you leave a comment and tell us, you’re like, Hey, I looked at this for three hours.\n[00:38:31] Nate Berkopec: I couldn’t reproduce it. That is super helpful for me because now I know, okay, someone tried to do this for three hours and they still couldn’t get it. Maybe this is not reproducible, maybe this isn’t actually a problem with Puma, so it’s, it’s really helpful for an open source project to find issues which are not currently don’t have a reproducible case and to try to try to find one.\n[00:38:54] Nate Berkopec: So I highly, highly encourage that.\n[00:38:56] Stefanni: Yeah, and, and just to emphasize, I don’t think, well, I believe I can say that for you, but correct me if I’m wrong. Mm-hmm. Or not say that if you don’t know how to reproduce, you can’t report the bug, but Oh, yeah. If, right. But if you,\n[00:39:13] Nate Berkopec: I mean, you have a bug, right? So Yeah. You should report it.\n[00:39:15] Stefanni: Yeah. So everyone can contribute on their ways. Um, yeah. But yeah, reproducing is really great. I think that’s also how we got started with Ruby on Rails, and we actually copied the reproduction script for Faker. Oh. Which is really, really helpful.\n[00:39:32] Nate Berkopec: Yeah. If, uh, if anyone listening is not aware of that, there’s a, like the, the Rails bug reproduction script is really, uh, very good and I think those are available if you go to like the Rails contributing guide on Rails guides and then like you kind of go down to the bug report section, you can find the links to all of them and it’s really cool and it’ll show you kind of in 30 lines.\n[00:39:54] Nate Berkopec: How they set up a Rails app to reproduce an issue in the most minimal way possible, depending on what part of rails you’re reporting the bug to. And it’s a really good example of how to make a, a minimal reproducible case, not only for a Rails app, but for really any, any Ruby project. Um, so yeah, I’ve done the same thing. I’ve copied that script multiple times.\n[00:40:15] Thiago: I guess even at your own job, if you’re not contributing or anything, maybe there’s a way to use those kinds of scripts to reproduce a bug. So you don’t have, um, what is it called again, when you, you don’t want the bug to appear again?\n[00:40:31] Stefanni: Ah, regress regression. Yeah.\n[00:40:32] Thiago: Regressions. Mm-hmm. You don’t want regressions, so this is really important, so mm-hmm. Add that little test there so you don’t have regressions. Mm-hmm. A cool habit sometimes to have. Yeah, absolutely.\n[00:40:45] Stefanni: Well, I think we got to, to the end of it, so we only have 10 minutes left. Is there anything else, Nate, that you would like to share about the issue, either about the issue or about the conversation we were having?\n[00:41:00] Nate Berkopec: Uh, nope. Um, I would say that, uh, if someone listening to this is interested in learning, More about working in a multi-threaded environment. Um, I do have a product called Sidekiq in Practice that has a number of live code examples that talk about thread safety and have other, it’s a intended to be a manual, like how to actually scale Sidekiq.\n[00:41:28] Nate Berkopec: And, uh, you know, cuz it’s Sidekiq. Uh, there’s a lot of things in there about threading and, and, um, how threads work in Sidekiq, why threads are important. It talks about the global VM lock, which we didn’t really discuss at all today. But, uh, if, if you are looking to learn more about threads and scaling the threaded environment, um, I do, I do sell something to help you with that. So go check it out.\n[00:41:51] Stefanni: Absolutely. I, it’s in my reading list. I really need to get it. I, which one should I read first? That one or the rails? The Guide to Rails performance? I don’t know.\n[00:42:07] Nate Berkopec: Um, I mean, yeah, it just depends on what, uh, your goal is first. They’re not, they’re not, um, intended like. You don’t have to read one to read the other.\n[00:42:18] Nate Berkopec: So if you’re interested in a more general perspective of how do I make a Rails app feel faster? How do I make it more scalable, like that’s the complete guide to Rails performance. If you were specifically having issues with Sidekiq and uh, scaling Sidekiq, I suggest reading that first.\n[00:42:35] Thiago: Yeah, that would be a nice episode to talk just about Sidekiq, because there are so many things to talk about. Sidekiq performance. Mm-hmm. We could do that in the future.\n[00:42:46] Stefanni: Yeah. Like how to log your workers, your scheduled workers, like how to. Logging and logging and retries jobs. Yeah.\n[00:42:57] Nate Berkopec: Yeah. I’ve had a lot of fun. My, my, my current client is, um, Gusto, which is a huge, um, payroll company in the United States, and they’ve got 600 plus engineers working on Sidekiq.\n[00:43:10] Nate Berkopec: And it’s been a really interesting experience to me to see kind of how Sidekiq scales like as an organization. So like what, what, what happens when 600 engineers all have queues and workers and like, that’s been a whole new side of Sidekiq that I’ve learned a lot about at, uh, at Gusto.\n[00:43:27] Thiago: Yeah, it sounds really exciting work, you know, a lot of problems and, and challenges to solve, which is kinda cool.\n[00:43:34] Thiago: Yeah, it’s been really cool\n[00:43:35] Stefanni: and yeah, and I think we’re supposed to call jobs now and not workers. I’m still getting used to the new terminology I need to catch up. I think I read something about that.\n[00:43:46] Nate Berkopec: Oh, that’s changed. I sh I feel like I should know that when I don’t,\n[00:43:48] Stefanni: I, I don’t know. I remember seeing a comment about that, like instead of me workers, you, you like change the folder in Rails or something?\n[00:43:57] Stefanni: Yeah, yeah. to jobs. No, I’m not really sure. I have to catch up. I just remember, uh, reading about that and they’re like, oh, I’ll probably need to read this some at some point. Hmm. Um, yeah, so I think we. At the end, and I would like to be respectful of your time, Nate, but thank you so, so much. I learned a lot and I know it was a bit of homework for you, but I hope it was fun.\n[00:44:23] Nate Berkopec: It was fun. Yeah, it was fun. It was fun. Nice to talk to you.\n[00:44:27] Thiago: Yeah. Yeah. It was, it was a very specific problem with a very specific solution, so it was nice to learn from that. Mm-hmm. I’ve learned a lot, so yeah. Thanks so much for, for sharing your expertise with us today.\n[00:44:40] Nate Berkopec: Great. My pleasure\n[00:44:42] Stefanni: Everyone, make sure to check out Puma and Nate’s books, the one about Sidekiq and Rails performance.\n[00:44:48] Stefanni: We’ll leave the links in the description notes if people want to know what you’re doing or wanna buy your books or your workshops as well. Where should they go?\n[00:44:59] Nate Berkopec: Uh, speedshop.co. Uh, this is where I have links to all that stuff.\n[00:45:05] Stefanni: Awesome. Cool. Cool. Thank you, Nate. Have a good weekend.\n[00:45:10] Nate Berkopec: Thank you.\n[00:45:11] Thiago: Thank you so much, Nate, for joining us today.\n[00:45:14] Thiago: And if you’ve learned something from this episode, please share with a friend and check out our newsletter at www.hexdevs.com/newsletter. I hope you’ve enjoyed this episode. See you on the next one.\nDid you like this article? You're gonna love these other ones:\nFetch a Pull Request from a branch you don’t own How to Open Source with Richard Schneeman (@schneems) How does the Faker Ruby Gem Work? ","wordCount":"8019","inLanguage":"en","image":"https://www.hexdevs.com/images/posts/hexdevs-podcast-fixing-a-ruby-thread-safety-bug-with-nate-berkopec.png","datePublished":"2023-04-03T21:06:49-07:00","dateModified":"2023-04-04T08:11:20-07:00","author":[{"@type":"Person","name":"Stefanni Brasil"},{"@type":"Person","name":"Thiago Araujo"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.hexdevs.com/posts/fixing-ruby-thread-safety-bugs-with-nate-berkopec/"},"publisher":{"@type":"Organization","name":"hexdevs","logo":{"@type":"ImageObject","url":"https://www.hexdevs.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://www.hexdevs.com/ accesskey=h title="hexdevs (Alt + H)">hexdevs</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://podcast.hexdevs.com/ title=Podcast><span>Podcast</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://www.hexdevs.com/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://www.hexdevs.com/about/ title="About us"><span>About us</span></a></li><li><a href=https://academy.hexdevs.com/ title="Get to Senior 🚀"><span>Get to Senior 🚀</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Fixing Thread Safety Bugs With Nate Berkopec</h1><div class=post-description>Can you tell if a Ruby gem is really thread-safe or not? And how do you fix a seemingly thread-safety issue that can be something else entirely?</div><div class=post-meta>38 min&nbsp;·&nbsp;Stefanni Brasil, Thiago Araujo</div></header><figure class=entry-cover><img loading=lazy src=https://www.hexdevs.com/images/posts/hexdevs-podcast-fixing-a-ruby-thread-safety-bug-with-nate-berkopec.png alt="Fixing Thread-Safety Bugs with Nate Berkopec"><p>Fixing Thread-Safety Bugs with Nate Berkopec (<a href=https://twitter.com/nateberkopec/>@nateberkopec</a>)</p></figure><div class=post-content><p>Can you tell if a Ruby gem is really thread-safe or not? And how do you fix a seemingly thread-safety issue that can be something else entirely?</p><p>We had no idea. So we asked Nate Berkopec to help us. Nate is an expert in Ruby performance.</p><p>The verdict: nuking all shared global mutable state in your Ruby code is a bad idea if you don&rsquo;t know what you&rsquo;re doing!</p><p>Listen to this episode to learn:</p><ul><li>How and why faker-ruby became thread-unsafe, especially for Puma users</li><li>Questions to ask yourself when trying to debug thread-safety issues</li><li>Shared global mutable state is not always the villain, and is not the source of all thread-safety issues</li><li>Nate&rsquo;s &ldquo;watch-out&rdquo; list of things that can cause undesired behavior when running multi-threaded Ruby applications: Constants, Class Variables, and Rack Middleware.</li></ul><p><iframe width=100% height=180 frameborder=no scrolling=no seamless src=https://share.transistor.fm/e/51c231bf></iframe>
<a href="https://podcasts.apple.com/ca/podcast/hexdevs/id1475721754?l=en">Apple Podcasts</a> | <a href=https://open.spotify.com/show/6wjI62ImWn3fYTru2r8sVw>Spotify</a></p><h2 id=about-nate>About Nate<a hidden class=anchor aria-hidden=true href=#about-nate>#</a></h2><p>Nate Berkopec runs Speedshop, a software performance company specializing in Ruby. He&rsquo;s also the maintainer of Puma, the popular Ruby webserver.</p><hr><h2 id=episode-links>Episode Links<a hidden class=anchor aria-hidden=true href=#episode-links>#</a></h2><ul><li><a href=https://academy.hexdevs.com>Get to Senior</a></li><li><a href=https://podcast.hexdevs.com/episodes/fixing-thread-safety-bugs-with-nate-berkopec>Podcast Interview with Nate Berkopec</a></li><li><a href=https://www.speedshop.co/>Nate Berkopec&rsquo;s Website</a></li><li><a href=https://www.railsspeed.com/>The Complete Guide to Rails Performance</a></li><li><a href=https://nateberk.gumroad.com/l/sidekiqinpractice>Sidekiq in Practice</a></li><li><a href=https://github.com/faker-ruby/faker/issues/2563>faker-ruby Bug Report</a></li><li><a href=https://ruby-doc.org/3.2.2/gems/minitest/Minitest/Test.html>mini-test parallelize_me!</a></li><li><a href=https://github.com/ioquatix/rack-freeze>rack-freeze</a></li><li><a href=https://github.com/mperham/connection_pool>connection pool</a></li><li><a href=https://github.com/rails/rails/tree/main/guides/bug_report_templates>Rails Bug Report Reproduction Scripts</a></li></ul><p>Thanks Valentino Stoll, nfstern02, and Gregg P for <a href=https://github.com/sponsors/hexdevs>sponsoring hexdevs</a>!</p><p>Enjoy!</p><h2 id=transcript>Transcript<a hidden class=anchor aria-hidden=true href=#transcript>#</a></h2><p>[00:00:00] <strong>Stefanni:</strong> Hey friends, Stefanni here. Welcome back to another hexdevs episode. Before we go to the episode, we want to thank Nate Berkopec for joining us on this episode about building tread-safe Ruby Code. As some of you might know, we help out at Faker Ruby, and we had an open issue that was related to thread-safety.</p><p>[00:00:28] <strong>Stefanni:</strong> And we were not quite sure how to fix that bug. So we sent a message to Nate and he kindly accepted the invite. And not only did he help us understand the issue, how to fix it, but he also gave us a lesson on building tread safe ruby code. Something else that we want to share is that this episode, and actually all of our episodes are sponsored by Get to Senior a program that we developed to help experience to Ruby developers take their careers to the next level.</p><p>[00:01:05] <strong>Stefanni:</strong> And we also have our Git Hub sponsor page. We have two sponsor: Valentino Stoll and Gregg P who have been supporting us. So thank you. And if you, dear Listener, wants to sponsor our work, go to hexdevs.com/get-to-senior or to our get GitHub page to see our sponsor page.</p><p>[00:01:35] <strong>Thiago:</strong> This is the hexdevs podcast. I&rsquo;m Thiago.</p><p>[00:01:38] <strong>Thiago:</strong> And I&rsquo;m Stefanni.</p><p>[00:01:39] <strong>Thiago:</strong> Today our guest is Nate Berkopec. Nate makes Rails apps go faster. He&rsquo;s an expert in Ruby on Rails performance. And he runs a company called Speed Shop, a software performance company specializing in Ruby. He&rsquo;s the maintainer of Puma, one of the most popular Ruby Web servers out there.</p><p>[00:02:00] <strong>Thiago:</strong> And he is also the author of the book, the Complete Guide to Ruby on Rails Performance. Thank you so much for joining us, Nate.</p><p>[00:02:06] <strong>Nate Berkopec:</strong> Hey, thank you very much.</p><p>[00:02:08] <strong>Stefanni:</strong> Yeah, we just gave Nate some homework to do. We sent him an email.</p><p>[00:02:16] <strong>Nate Berkopec:</strong> Yeah. What the heck, man? I thought this was a podcast, not like a class. I had to go take,</p><p>[00:02:24] <strong>Stefanni:</strong> Well, we had a, an issue that was opened on faker not being thread safe. So we didn&rsquo;t know exactly what to do, how to solve the issue, and we thought it would be a great opportunity to bring Nate, who&rsquo;s an expert in all of that, to talk more about why faker is not tread safe. And then we could also use this example to understand more how to build thread safe Ruby apps.</p><p>[00:02:59] <strong>Stefanni:</strong> So thank you so much Nate. And sorry to give you homework.</p><p>[00:03:05] <strong>Stefanni:</strong> Yeah. So I would like to get started with a heads up about what caught your attention about the issue, why. Is faker not thread-safe?</p><p>[00:03:18] <strong>Nate Berkopec:</strong> Yeah. So you, you brought me in, uh, and sent me this link to this report. So this was actually after you thought you had fixed a threadsafety issue on faker and so.</p><p>[00:03:33] <strong>Nate Berkopec:</strong> Basically in faker. So if you&rsquo;re not familiar with faker, faker is like this extremely commonly used gem for, uh, generating fake data, usually in tests. So you can like, ask for last names. First names, like all, it&rsquo;s like anything you can think of, faker can pretty much generate a random version of it, right?</p><p>[00:03:55] <strong>Nate Berkopec:</strong> Mm-hmm. So, Faker also works with locales. So you can have, you know, Japanese data, English data, whatever. Right? So you need to tell it what locale it, it, it&rsquo;s gonna generate that data for. So there is a setting and that, uh, locale setting, uh, I think has always been, I don&rsquo;t think this was changed ever. &lsquo;Faker::conf.locale =&rsquo;. Okay, so that was how you said it. You said that to a, a symbol, I believe you had said it to, you know, en-GB or, or JA or whatever your, your locale is. So there was a, a PR for two included in 2.23, which changed how this worked. And originally, and this was your PR Tiago. The, the PR that I&rsquo;m about to describe that change, or is it not?</p><p>[00:04:53] <strong>Thiago:</strong> No, I just approved it.</p><p>[00:04:55] <strong>Nate Berkopec:</strong> Oh, you just approved it. Okay.</p><p>[00:04:56] <strong>Thiago:</strong> I did the review and then I&rsquo;m pretty sure someone else worked on that. Yeah. Oh yeah, it was someone else, but I gave my thumbs up.</p><p>[00:05:04] <strong>Nate Berkopec:</strong> It&rsquo;s still your fault. I see. I can, yeah, for sure. Oh, everybody&rsquo;s fault.</p><p>[00:05:09] <strong>Nate Berkopec:</strong> Blame the reviewer. Um, so the way that this originally worked was faker config. The module had a, uh, locale. Class variable. So you would set the class variable with locale equals, and you would read it with locale, right? So that&rsquo;s works. That&rsquo;s fine. You know, it means that all threads and everything, like if you create a new thread, it&rsquo;s still gonna read that same value, right?</p><p>[00:05:41] <strong>Nate Berkopec:</strong> So that, that all works. But, If more than one thread tries to write that value, we start to have problems. Right? So somebody basically made an issue that was like, I use faker in QA. And in QA we&rsquo;re sending different requests that have different locales. And so the faker. Data, uh, faker is like setting the locale in one thread and then being that a different thread is reading that locale, which has now been overwritten and we don&rsquo;t want that to happen.</p><p>[00:06:13] <strong>Nate Berkopec:</strong> So basically the request was that faker should be thread safe. But to to, to rephrase this as more of like a story, the desired behavior is, and you can correct me, this is what I&rsquo;m a little unclear on, so you can, you can correct me if I&rsquo;m wrong about this. I think the desired behavior. Is that we should set a default locale, uh, in a, in configuration, like when we start the app.</p><p>[00:06:38] <strong>Nate Berkopec:</strong> And if we don&rsquo;t say anything else, this will, this will be the default locale, and then threads should be able to, in a thread safe way, change the locale on a per thread basis. Okay, so you could, you know, if this, if this was, if, if this feature was available, you could, in Puma or any other multi-threaded web server, you could set the locale in a maybe rack middleware or something, I don&rsquo;t know, like in a before act in a around action in Rails, you would change the locale in faker and then do whatever work you wanted to do, you know, run the rest of the action and.</p><p>[00:07:16] <strong>Nate Berkopec:</strong> In an ensure block, you could say, set the locale back to what it was before. And um, that would be how you could change that locale. And then you, then you could have like per request locales in a thread-safe way. That. Is that, is that correct? That sounds, that sounded like the desired behavior to me.</p><p>[00:07:32] <strong>Thiago:</strong> Yeah, that&rsquo;s the desired behavior. I think we had that before, but it wasn&rsquo;t tread safe. And then someone wanted to have different threats and not have one overriding the locale on the other tread, and then that was fixed. But then the other person say, Hey, but then you fix my set up now where I run this, I guess in production, I think. Mm-hmm.</p><p>[00:07:53] <strong>Thiago:</strong> When someone else runs it in production. And now if I use faker in production and I set the locale, It only exists like in one of the requests and then the others don&rsquo;t, don&rsquo;t see that anymore. And so it&rsquo;s kind of like one fix broke someone else&rsquo;s setup, and then we have to fix both things now.</p><p>[00:08:13] <strong>Nate Berkopec:</strong> Right. So the, the, the change that was made to try to implement this story was that, uh, locale is no longer just, uh, an at a class attribute. Uh, class, uh, instance class variable. It is a, uh, it sets thread dot current, uh, open bracket, faker config locale, close bracket. And we&rsquo;re re so we&rsquo;re, we&rsquo;re writing, writing and reading thread dot current. Some thread, well, we thought it was a thread variable, and then you, you know, you learn later in the issue is people read the docs.</p><p>[00:08:52] <strong>Nate Berkopec:</strong> It&rsquo;s actually fiber local. So that was the change. The instance, the the locale instance, uh, I keep saying instance, it&rsquo;s not an in class instance variable. It&rsquo;s a class variable. That class variable locale was removed, completely removed. And there&rsquo;s some other stuff in here, which I actually haven&rsquo;t looked at there.</p><p>[00:09:08] <strong>Nate Berkopec:</strong> You have some other like thread dot current use. Like you, you&rsquo;ve removed basically several class variables replace them with thread dot current is kind of the theme here. Uh, local, like this local setting is kinda the one I&rsquo;m just going to talk about it cause it&rsquo;s the one I looked at and it&rsquo;s, it&rsquo;s a good example of everything else here.</p><p>[00:09:26] <strong>Nate Berkopec:</strong> So then the bug report comes in and per this person&rsquo;s like this broke something else for me. So, uh, you set up a Rails app in Puma or other threaded web server, you set faker dot conf, faker config dot locale, and Initializer make a request. And then you get the fake data for the default locale for faker, which is en, so the, the faker config dot local setting broke for all Puma users using more than one thread.</p><p>[00:09:58] <strong>Nate Berkopec:</strong> Um, or actually I think it should be any threadat all. So basically it broke it for Puma completely. So let&rsquo;s talk about why that happened. Cause I think if you understand why this happened, then like the fix here becomes more obvious. How Puma works. So Puma, when it starts up, it has one process and one thread to when it starts, uh, when it starts itself.</p><p>[00:10:23] <strong>Nate Berkopec:</strong> And depending on the, uh, mode you have it set to, it may or may not start other processes. But the important thing here is that when Puma processes requests, it sends the request into what we call the um, Our thread pool, which act has a different name? Uh, in pool? No, I guess we just call it the thread pool.</p><p>[00:10:45] <strong>Nate Berkopec:</strong> Yeah. So it&rsquo;s the puma thread pool. And, um, that thread pool has anywhere from one to X number of threads where, you know, you set it to whatever you want. So the application request is always processed in a different thread than the thread that Puma was started with. So we. Start the Puma server. We initialize your application, run all the initializers, and then we create the threads for the thread pool.</p><p>[00:11:17] <strong>Nate Berkopec:</strong> Okay? So that timing is important here because the initializer is run before we create the app, uh, app application threads that, that actually run the, the application requests. So that faker config dot locale is called. Before those, uh, thread pool threads are created, behavior of thread dot current and, uh, sorry, not thread dot current, but the, this is the bracket method.</p><p>[00:11:46] <strong>Nate Berkopec:</strong> On, on a thread instance, you, uh, instance method, uh, uh, on a thread you could say. So this is accessing thread. No fiber local variables as, as, uh, the documentation points out. So, um, in case you don&rsquo;t know, all threads have fibers. Fibers are lower level concurrency unit than a thread. So, um, all processes have at least one thread, and all threads have at least one fiber in Ruby.</p><p>[00:12:14] <strong>Nate Berkopec:</strong> Okay? So some puma doesn&rsquo;t do this and, uh, your application might create new threads, but, uh, Create new fibers, I should say. But Puma doesn&rsquo;t actually create new fibers. So for our purposes in this conversation, it&rsquo;s, it&rsquo;s, uh, there are no like a thread, it is a thread, uh, variable because there&rsquo;s, we don&rsquo;t have, we don&rsquo;t have multiple fibers here.</p><p>[00:12:37] <strong>Nate Berkopec:</strong> So, so the thing is, is like when you create these, these fiber local variables with, uh, the bracket method, they&rsquo;re not inherited. So there&rsquo;s a really great reproduction in this issue. Um, when you scroll down a bit where someone made like the minimally, the minimally, uh, required reproduction. And all they did was set the fiber, uh, in the current thread, set the, uh, faker locale, then create a new thread inside of that thread, set it again, and then try to read what that was.</p><p>[00:13:08] <strong>Nate Berkopec:</strong> And, uh, it was, it reproduced the bug in 10 lines of code. Really, really, first of all, as an open source maintainer. That&rsquo;s exactly what we wanna read, right? We wanna read the 10 line reproduction. It&rsquo;s. So good job to that person that wrote that. So these, these, these variables are not inherited. So like Puma creates the, the, uh, thread pool to run your, like the threads that actually run the app.</p><p>[00:13:31] <strong>Nate Berkopec:</strong> And now this locale fiber variable is no longer set. So it goes back to the default value of, of English. So that was the, that was the source. Of the bug here. So does that all, does that all make sense? I&rsquo;ve been talking a lot now. I&rsquo;m, I&rsquo;m done talking.</p><p>[00:13:49] <strong>Thiago:</strong> Yeah, for sure. That makes a lot of sense.</p><p>[00:13:52] <strong>Stefanni:</strong> Mm-hmm. Yeah. That, that was Matheus, uh, he has been helping a lot with, with this issue, like I am learning.</p><p>[00:14:04] <strong>Thiago:</strong> Yeah. I&rsquo;m curious to know about, because you mentioned that the fiber local variable is not inherited. Right. The other threads. Mm-hmm. But then if we talk about the class variable, right? If I said that class variable on the initializer right, it would be available to all the other threads. Is that Yes. How it works?</p><p>[00:14:29] <strong>Nate Berkopec:</strong> Yes. Yep. And this is like, uh, this is kind of the, uh, to me, like the, uh, fine grained part of this issue. When it comes to thread safety, it&rsquo;s just like people are like, okay, we gotta get rid of all shared mutable, state shared mutable state is bad, get rid of it. And that&rsquo;s like what the PR did, right?</p><p>[00:14:51] <strong>Nate Berkopec:</strong> Like it nuked the shared mutable state. No more class variables don&rsquo;t do it. But like you actually do want shared mutable state. In this story, like you want to be able to change the locale for all threads at a particular point in time, right? You want to do that during initialization when there aren&rsquo;t, when, when you know there aren&rsquo;t multiple threads, probably trying to read this value and do stuff with it.</p><p>[00:15:21] <strong>Nate Berkopec:</strong> Like there&rsquo;s not, like you, you, you wanna do that during a time when it&rsquo;s probably safe to do it and then later you want the, uh, private state you want thread private state, right? So it&rsquo;s kind of like a, uh, a little bit complicated there, where like, you want both things, right? Like you want to be able to override this value for all threads.</p><p>[00:15:42] <strong>Nate Berkopec:</strong> You just wanna be able to do it at a particular time. Um, so the original PR was, uh, thread safe, but just also didn&rsquo;t work. So you, you, you gained thread safety while breaking the feature. Yeah.</p><p>[00:15:56] <strong>Thiago:</strong> Yeah. It&rsquo;s interesting that. Maybe threadsafety is not always the, the goal. Depending on your feature, maybe you want to be able to share state between threats and maybe if you want to mutate the global state, then you have to worry about thread safety and how you, you would approach that.</p><p>[00:16:17] <strong>Thiago:</strong> But in this case, you broke the feature by doing that. Right. Which is kind of interesting.</p><p>[00:16:23] <strong>Nate Berkopec:</strong> Yes, and, and sometimes it&rsquo;s also a little bit complicated here because. You, you also don&rsquo;t, in this story, right, you don&rsquo;t actually really care about the thread safety of setting this locale for all threads. Like you could write this in such a way that, like, the class variable is, is that access and, and reading is thread safe.</p><p>[00:16:51] <strong>Nate Berkopec:</strong> So like we could use, um, something from concurrent Ruby, for example. It&rsquo;s a library, a ruby gem that&rsquo;s used in Rails. And, um, we could set this up so that it&rsquo;s thread safe to change the locale for all threads, but you don&rsquo;t really actually care about that because the only time you&rsquo;re gonna do that is during app initialization.</p><p>[00:17:11] <strong>Nate Berkopec:</strong> And so, or we could write our own thing with a mutex or whatever to do this, but. You don&rsquo;t really actually care about the thread safety there, because that happens during initialization where, where there&rsquo;s only one thread running anyway. So like you could add that to like, you know, check all your thread safety boxes here.</p><p>[00:17:25] <strong>Nate Berkopec:</strong> But what you really wanted was like private thread state. Like you want to be able to change this value on a per thread basis and not have, not have it affect other threats. Okay. So that&rsquo;s, To me that&rsquo;s like a little bit different than thread safety. There&rsquo;s a, there&rsquo;s a thread safe way to, to implement this that would still not satisfy the story if we just took the original behavior of the locale class variable and made that access, um, thread safe.</p><p>[00:17:57] <strong>Nate Berkopec:</strong> What would happen is, is every, every request would change the locale for all other running requests. So like in the middle of a, a halfway through a rendering a response, the faker locale could be changing because other threads are changing. That locale value that you don&rsquo;t want that, right? Like you don&rsquo;t want global state, you want per thread state.</p><p>[00:18:18] <strong>Nate Berkopec:</strong> So like threadsafety is more complicated than just it is thread-safe or not be depending on what, uh, behavior you desire.</p><p>[00:18:26] <strong>Stefanni:</strong> Yeah, and I also think it&rsquo;s really easy to. Create those bugs because I don&rsquo;t think most of us are aware of those details.</p><p>[00:18:39] <strong>Nate Berkopec:</strong> Um, I think in general, this doesn&rsquo;t happen in application development because most of this. It&rsquo;s just like very uncommon to need to write or need to use class variables, for example. So the common sources of of thread safety issues, generally you don&rsquo;t reach for these like tools that cause these problems in application development, but it does happen all the time in library development. So the most common causes of thread safety issues are class variables. Global variables, which used to be a thing that people did, but I don&rsquo;t know, mostly people don&rsquo;t even reach for them anymore and just use constants. Um, constants and uh, rack middleware. So those three things. Of those three things, really, constants is the only thing I see people making mistakes with in application development.</p><p>[00:19:34] <strong>Nate Berkopec:</strong> But when you&rsquo;re doing libraries, class variables and in rack middleware, it&rsquo;s very common to have those, those things. And so you can really. You need to know more about threadsafety when you&rsquo;re, when you&rsquo;re writing libraries, I think, than, than writing rails applications, for example. Mm-hmm.</p><p>[00:19:49] <strong>Thiago:</strong> For sure. I&rsquo;m curious about the cases you mentioned about like constants, that being a problem. Is that because people try to modify, uh, the value of a constant Yes. At front time?</p><p>[00:20:03] <strong>Nate Berkopec:</strong> Yeah, exactly. Like, um, setting a constant to like a collection, like a, an array or. Those accesses are not, uh, thread safe. Even, uh, Samuel Williams, the maintainer of, of uh, uh, Falcon, the web server has, has also had this demo where he&rsquo;s shown that hash access is not, uh, thread safe in hash.</p><p>[00:20:26] <strong>Nate Berkopec:</strong> Just half hash access is in writing is not thread safe in new, you can even like corrupt the hash, uh, end up with all these crazy behaviors. So yeah, setting constants to collections. And then modifying those collections. So there, there was like a trend, uh, I don&rsquo;t know, like two years ago, no more than that, I don&rsquo;t know, four or five years ago to like freeze constants.</p><p>[00:20:50] <strong>Nate Berkopec:</strong> And we used to do this mostly as a memory saving measure. So like when you freeze an object, Ruby internally allows everybody, everyone that uses that constant can like point to the same object. So we used to like just put a lot of things in constants and freeze them. Uh, now there&rsquo;s like this Rubocop rule that tells you to freeze everything you put into a constant.</p><p>[00:21:10] <strong>Nate Berkopec:</strong> And freezing is nice from a memory usage perspective, but it&rsquo;s even better from a, from a, uh, thread safety perspective because now you get an error, right? If someone tries to modify the object, the, you can still get these problems though with freezing because you can satisfy the rubocop rule. By calling freeze on an array inside of a constant.</p><p>[00:21:32] <strong>Nate Berkopec:</strong> But if you have a array inside of that array, rubocop won&rsquo;t say anything. And you still have a threadsafety issue because you&rsquo;re modifying this unfrozen array inside of the constant. So anything that&rsquo;s accessible from that constant really can, can lead to a threadsafety issue. So I, I think I see that issue sometimes in app development where people create, um, caches that they want to use. That&rsquo;s kind of the most common thing is they put a cache inside of a constant and then they end up with a threadsafety issue there. Or the other one I see is, uh, database connections. So if you put a database connection inside of a, a constant, for example, if you just like capital Redis equals redis.new, the issue you&rsquo;re gonna get there. Everybody accessing that con, accessing that constant is getting the same exact database connection.</p><p>[00:22:21] <strong>Nate Berkopec:</strong> So if you have two threads accessing the same database connection, you can end up with issues where one thread gets the response for another thread. Um, so you don&rsquo;t wanna do that and uh, there&rsquo;s like a lot of gems that help you with this.</p><p>[00:22:34] <strong>Nate Berkopec:</strong> But basically you need to set it up so that each thread is getting its own connection out of the, uh, connection pool. Um, so those are the most common ones I see in day-to-day app.</p><p>[00:22:44] <strong>Thiago:</strong> That&rsquo;s interesting. A good rule of thumb, maybe if you&rsquo;re working with constants and you&rsquo;re trying to do something weird or adding some hashes or arrays to the constant, you gotta be careful what you&rsquo;re doing.</p><p>[00:22:59] <strong>Thiago:</strong> Yeah. Or a database connection. Yeah. Cool. Mm-hmm.</p><p>[00:23:04] <strong>Stefanni:</strong> And, and like since you are talking about those common. Things that you see happening in, in development, um, is there something that we as developers could change how we see? Things when we are implementing them. Like how can we start paying more attention to, to those potential thread, safe, uh, issues?</p><p>[00:23:33] <strong>Stefanni:</strong> Because like you mentioned, it&rsquo;s not something that we do it every day, for example. Nowadays, I think it&rsquo;s more common for us to know, oh, this is gonna have a, any plus one query or something like that. So how can we start changing our, our ways of working to. start identifying, those issues. Yeah.</p><p>[00:23:53] <strong>Nate Berkopec:</strong> My biggest, um, recommendation is always to make your test multi-threaded.</p><p>[00:24:00] <strong>Nate Berkopec:</strong> So, uh, if you are using Minit test, um, you can run each test inside of its own thread. It&rsquo;s called mini test. Oh man. Now I&rsquo;m gonna forget, uh, let me get this mini test cause. Yeah, parallelize is what it&rsquo;s called. So, um, if you require mini tests slash parallel on a test, uh, or no, include it. Uh, now I&rsquo;m, I&rsquo;m not gonna remember it, but look it up.</p><p>[00:24:30] <strong>Nate Berkopec:</strong> Um, but yeah, you could, you can set up mini tests so it runs each test in a different threat. So that covers your unit tests and makes all your unit tests multi-threading. Um, so if you&rsquo;re just running minit tests, uh, I suggest turning that. If you&rsquo;re using RSpec, you&rsquo;re outta luck. Sorry. Uh, RSpec isn&rsquo;t multi-threaded, never will be.</p><p>[00:24:50] <strong>Nate Berkopec:</strong> So you&rsquo;re stuck. Uh, your only option for multi-threaded tests is to convert them to mini-test. Um, so, you know, good luck.</p><p>[00:24:59] <strong>Stefanni:</strong> Oh, I was gonna say, okay. What about RSpec? Yeah.</p><p>[00:25:03] <strong>Nate Berkopec:</strong> Uh, for integration and system tests, so, System tests start a puma server or integration test. Can, you know, you can set up to do whatever you want, right?</p><p>[00:25:15] <strong>Nate Berkopec:</strong> But you should set up your integration test to set up to start a Puma server and run that puma server with multiple threats. So that will also potentially flush out, uh, threading bugs. Now this is also gonna make your, your test suite less stable like you can. Make a threading bug, usually you can&rsquo;t cause it like a hundred percent of the time, so you&rsquo;re gonna start getting flakes probably where they&rsquo;re caused by threads.</p><p>[00:25:44] <strong>Nate Berkopec:</strong> Like we, you can&rsquo;t just like write a test that&rsquo;s like always triggers a, the thread bug most of the time. So, um, it will probably make your test less stable, but like, you know, that&rsquo;s, that&rsquo;s kind of the price you&rsquo;re gonna pay here. That to me is like, the best possible thing is make your test multi-threaded.</p><p>[00:26:01] <strong>Nate Berkopec:</strong> So you are actually testing, uh, thread safety. Second thing is like all you can really do is look for those three different sources of, of threading bugs that I talked about. Anytime you&rsquo;re writing your own rack middleware. So the, the, the threadsafety issue here is that, um, there is only one rack middleware stack for, for an application, right?</p><p>[00:26:25] <strong>Nate Berkopec:</strong> So, The objects that are created in for, to that actually run your rack middleware, there&rsquo;s only one of those for every application, um, or every, you know, uh, process. So your application runs in different threads, but they&rsquo;re all using the same rack middleware objects. So if you have an instance variable inside of a rack middleware, you can end up with a thread safety issue.</p><p>[00:26:50] <strong>Nate Berkopec:</strong> The fix is actually really easy. There is a, uh, middleware. Freezer that, uh, uh, Samuel Williams wrote called Rack dash Freeze, and. It basically ensures that your rack middleware are, are thread safe by freezing all of your instance variables. Um, and so you can&rsquo;t possibly cause a problem and it&rsquo;ll blow up if you try to do thread unsafe things.</p><p>[00:27:18] <strong>Nate Berkopec:</strong> So take a look at that. For rack middleware, for constants, I think probably everybody should audit constants, created and Initializers, um, for this issue that I talked about. Basically look, make sure you know what you&rsquo;re putting into constants, uh, is not a collection that&rsquo;s going to be modified and is not, uh, you know, just a straight up database connection.</p><p>[00:27:43] <strong>Nate Berkopec:</strong> There&rsquo;s for database connections, there&rsquo;s a gem called Connection pool. This is, uh, I think still maintained by Mike Perham. Yeah, so Mike wrote it. I think he wrote it originally anyway, but it&rsquo;s mper. From Sidekiq, M P M P E R H A M slash connection underscore pool. This is like a generic connection pooler that works with any, uh, underlying database connection gem.</p><p>[00:28:07] <strong>Nate Berkopec:</strong> So you can get thread safe connection pools that will work with, um, with threads. So you would assign that to a constant instead of, uh, just like redis.new. And then for class variables, those are a little bit easier because hopefully you can just find the at, at like the, at looking for the @@ is like, you know, control F your code base for that.</p><p>[00:28:30] <strong>Nate Berkopec:</strong> But, um, you and the original, uh, PR actually you had class inherits from self and then it was at locale equals. So like, since you can always do that, it&rsquo;s kind of hard to like just grep through a code base for class variable. Um, but uh, if you see a file that has a class variable in it, you know, that is shared global mutable states, so you know, it&rsquo;s only thread unsafe when it, someone tries to write to it from multiple threads.</p><p>[00:28:59] <strong>Nate Berkopec:</strong> So just because these exist doesn&rsquo;t mean I think that you should be replacing them all the time. Often, like one thing that, uh, happens is. Someone needs to write a value to a, uh, class variable, and then multiple threads want to read that value. If the writer method, if every thread will just write the same thing.</p><p>[00:29:26] <strong>Nate Berkopec:</strong> To the class variable, like initialize, like a default value, and then everybody reads the same value after that. That&rsquo;s not really a thread safety issue because every thread is trying to write the same value, right? So it doesn&rsquo;t, it doesn&rsquo;t matter that they could possibly access the, the, the thread ver uh, variable at the sa, the class variable at the same time, because they&rsquo;re gonna try to write the same thing.</p><p>[00:29:46] <strong>Nate Berkopec:</strong> So who cares. So it&rsquo;s like there can be shared global state without there being a thread safety issue, but I think you have to be aware every time you see a class variable or class instance variable that, um, What, think about what, what is trying to write to this and when is it trying to write to this and could there possibly be an issue there?</p><p>[00:30:06] <strong>Stefanni:</strong> Yeah. I like the questions to ask before you go out there and try to replace everything.</p><p>[00:30:14] <strong>Nate Berkopec:</strong> Because, because this is complicated, right? Like Yeah. Especially with class variables. Um, you know, writing the mutex dot synchronized stuff, like you&rsquo;ve probably never written anything with mutex before. You know, pulling something out of concurrent ruby that you&rsquo;ve never used before and using like a, a data structure out of concurrent Ruby, like, it&rsquo;s not the easiest thing in the world.</p><p>[00:30:35] <strong>Nate Berkopec:</strong> So, um, you know, definitely try to avoid it if you can. Um, so yeah, I mean, and people smarter than all of us have done that and then made a mistake anyway, so yeah, it&rsquo;s, uh, it&rsquo;s not easy stuff.</p><p>[00:30:50] <strong>Thiago:</strong> Maybe one thing that exacerbates the problem is that we are very used to. Thinking in Ruby, it&rsquo;s just like, it&rsquo;s just one tread and you don&rsquo;t have to use other treads or anything like that cuz compared to maybe other languages, when we say, oh, in Java, be careful with static variables and things like that.</p><p>[00:31:11] <strong>Thiago:</strong> But in Ruby, We don&rsquo;t talk about that a lot, uh, about concurrency. At least, at least in rails. Like it&rsquo;s just, you don&rsquo;t have to worry too much about that request is one thread and you don&rsquo;t have to worry about those things. Yeah. But then when you run into those weird. Bugs, you&rsquo;re not sure what to do. You just, you just think, oh, I don&rsquo;t know what that is.</p><p>[00:31:34] <strong>Thiago:</strong> I don&rsquo;t, I have no idea why this is happening. But if you try again, you, you&rsquo;re not gonna have the problem. And so I&rsquo;m curious about what kind, what kind of things people can do so that when they run into a weird problem, they came, they can point and say, oh, maybe this is a thread safety bug instead of something else.</p><p>[00:31:55] <strong>Thiago:</strong> So maybe like some strategies or some. Some characteristics. Oh, it&rsquo;s pretty soft books.</p><p>[00:32:01] <strong>Nate Berkopec:</strong> It&rsquo;s pretty easy. Yeah. Like if, if every time I hear, uh, oh one request, no, the request A got the response for request B. So every time I hear like, oh, someone is getting someone else&rsquo;s responses. And that&rsquo;s obviously a security issue, right?</p><p>[00:32:22] <strong>Nate Berkopec:</strong> That&rsquo;s always, that&rsquo;s, that&rsquo;s kind of how this usually comes up is like, oh no, somebody got authorized to someone else. Account because they got someone else&rsquo;s cookie header, something like that. Right? So anytime I hear, uh, one user A got the response for user B, it&rsquo;s like thread safety issue immediately.</p><p>[00:32:39] <strong>Nate Berkopec:</strong> So that, that&rsquo;s probably the most common one at the application level that I, that I hear about the faker issue specifically. I think maybe you, we kind of all knew because it was like, oh, it was this change. Or like someone realized it was only in Puma. I guess that&rsquo;s the other, yeah, if it, if it, if switching to unicorn fixes the issue, then you know it&rsquo;s a threadsafety issue.</p><p>[00:33:02] <strong>Nate Berkopec:</strong> Right. So, um, cuz in unicorn you don&rsquo;t even have, there&rsquo;s no, um, like for example, so I talked about how Puma starts essentially even in the, in the, in the simplest case, it has to start two threads. It has the thread that starts Puma and boots your app, and then the thread that actually runs the application.</p><p>[00:33:21] <strong>Nate Berkopec:</strong> Right. Technically we&rsquo;re running your application single-threaded there. Like the actual, uh, every request that comes in to that puma process will always be processed by the same thread. So yes, like it technically is single threaded, but we kind of have this like thread issue, right? With faker even in that scenario because that fiber local variable was not inherited.</p><p>[00:33:48] <strong>Nate Berkopec:</strong> If moving to Puma breaks the fix, breaks the issue and, and getting off of it fixes it, then you know you have a thread safety issue. Um, but yeah, I think generally like any issue where state is kind of correct for one person but not correct for someone else, and it&rsquo;s flaky and random, uh, then the, your, your thread safety issue, spider sense should be t.</p><p>[00:34:17] <strong>Thiago:</strong> Yeah. It&rsquo;s not Puma&rsquo;s fault either. It&rsquo;s just the way Yeah.</p><p>[00:34:21] <strong>Nate Berkopec:</strong> I mean, it&rsquo;s your fault threat. Puma&rsquo;s thread safe. You&rsquo;re not, so it wasn&rsquo;t me, man. Yeah,</p><p>[00:34:31] <strong>Stefanni:</strong> yeah. That was, that was a hard one. And we were like, I think we should ask for someone who knows how to fix this issue. Yeah. Cause we, we were not sure and. I think it&rsquo;s also, it&rsquo;s something that I want to see more is people say, uh, well, developers saying that they don&rsquo;t know things right, and they ask for help.</p><p>[00:34:55] <strong>Stefanni:</strong> So I thought this would be a, a good way to, to do that.</p><p>[00:35:03] <strong>Nate Berkopec:</strong> Yeah, and like when I started maintaining Puma, I knew nothing. So like mm-hmm. In 2016 when Evan Phoenix, the original author, like, asked me to start maintaining Puma, like I didn&rsquo;t know anything about threads, thread safety, or all the other like kind of specific. Things that Puma needs to run. Like, um, knowing about sockets, TCP, UDP, like the f the deep specifics of HTP, um, C extensions.</p><p>[00:35:36] <strong>Nate Berkopec:</strong> Like, I didn&rsquo;t know any of that when I started maintaining Puma. And, uh, now I, I know a lot more, but um, when I started I didn&rsquo;t know anything. So like, we all start not knowing anything. So, um, you know, we are, we every one that you ask a question about thread-safety or whatever. At one point, they didn&rsquo;t know the answer to that either.</p><p>[00:35:56] <strong>Nate Berkopec:</strong> So yeah, I don&rsquo;t think you should feel, uh, intimidated about asking, uh, asking questions like that.</p><p>[00:36:02] <strong>Thiago:</strong> And it&rsquo;s also a cool opportunity for contributors. So for example, Matheus who&rsquo;s. Taking a look at that issue, he said, oh, I don&rsquo;t know anything about threads but I&rsquo;ll try to learn something. And then he learn a couple of things and shared.</p><p>[00:36:19] <strong>Thiago:</strong> And so it&rsquo;s just a nice way to, to learn more because. You don&rsquo;t really have to know before you get started on an issue. And then eventually if you continue working on that, you, you&rsquo;re gonna figure it out and then we can have nice conversations about that. It&rsquo;s kinda cool. Yeah.</p><p>[00:36:36] <strong>Nate Berkopec:</strong> Yep. And I think, um, one thing that, I&rsquo;ll bring it up again that Matheus did that was just like really important for that was to get the minimal reproducing case.</p><p>[00:36:46] <strong>Nate Berkopec:</strong> So when he had that 10 line example that reproduced the issue. That&rsquo;s so important for learning because then you have this little experiment that you can, that you can try things on. So you can say, oh, if I change this over here, does that, how does that change the behavior? In my, in my example, um, if you don&rsquo;t have the minimal reproducible example, it&rsquo;s much more difficult to to learn because you don&rsquo;t have a little tool that you can change things on and see what happens.</p><p>[00:37:11] <strong>Nate Berkopec:</strong> So getting to that minimal example was so important, I think for. For where he went and the rest of the issue. So, um, if I have any advice with that is to like do to, to emulate that behavior to, you know, find, try to try to get to the 10 line example that reproduces the problem.</p><p>[00:37:29] <strong>Stefanni:</strong> Yeah, I love that. It&rsquo;s, it&rsquo;s a very underrated way to get started.</p><p>[00:37:37] <strong>Stefanni:</strong> We&rsquo;ve not only contributing to open source, but I think almost anything related to developmental, let&rsquo;s say. Because you, you get to just try. You&rsquo;re not trying to fix anything. You&rsquo;re just trying to find what is going on. And you learn a lot about things</p><p>[00:37:53] <strong>Nate Berkopec:</strong> in Puma, on GitHub, uh, we have a needs repro label, uh, as a needs reproduction, and I put that on any issue where the original poster has not provided a similarly simple example that can just be run and, and uh, and reproduce it.</p><p>[00:38:13] <strong>Nate Berkopec:</strong> Um, in Puma, if you&rsquo;d like to contribute. Um, that&rsquo;s one way to do it is you go to the needs repro label and just try to reproduce people&rsquo;s issues. And I can tell you as a maintainer, it&rsquo;s also helpful if you can&rsquo;t reproduce it and you leave a comment and tell us, you&rsquo;re like, Hey, I looked at this for three hours.</p><p>[00:38:31] <strong>Nate Berkopec:</strong> I couldn&rsquo;t reproduce it. That is super helpful for me because now I know, okay, someone tried to do this for three hours and they still couldn&rsquo;t get it. Maybe this is not reproducible, maybe this isn&rsquo;t actually a problem with Puma, so it&rsquo;s, it&rsquo;s really helpful for an open source project to find issues which are not currently don&rsquo;t have a reproducible case and to try to try to find one.</p><p>[00:38:54] <strong>Nate Berkopec:</strong> So I highly, highly encourage that.</p><p>[00:38:56] <strong>Stefanni:</strong> Yeah, and, and just to emphasize, I don&rsquo;t think, well, I believe I can say that for you, but correct me if I&rsquo;m wrong. Mm-hmm. Or not say that if you don&rsquo;t know how to reproduce, you can&rsquo;t report the bug, but Oh, yeah. If, right. But if you,</p><p>[00:39:13] <strong>Nate Berkopec:</strong> I mean, you have a bug, right? So Yeah. You should report it.</p><p>[00:39:15] <strong>Stefanni:</strong> Yeah. So everyone can contribute on their ways. Um, yeah. But yeah, reproducing is really great. I think that&rsquo;s also how we got started with Ruby on Rails, and we actually copied the reproduction script for Faker. Oh. Which is really, really helpful.</p><p>[00:39:32] <strong>Nate Berkopec:</strong> Yeah. If, uh, if anyone listening is not aware of that, there&rsquo;s a, like the, the Rails bug reproduction script is really, uh, very good and I think those are available if you go to like the Rails contributing guide on Rails guides and then like you kind of go down to the bug report section, you can find the links to all of them and it&rsquo;s really cool and it&rsquo;ll show you kind of in 30 lines.</p><p>[00:39:54] <strong>Nate Berkopec:</strong> How they set up a Rails app to reproduce an issue in the most minimal way possible, depending on what part of rails you&rsquo;re reporting the bug to. And it&rsquo;s a really good example of how to make a, a minimal reproducible case, not only for a Rails app, but for really any, any Ruby project. Um, so yeah, I&rsquo;ve done the same thing. I&rsquo;ve copied that script multiple times.</p><p>[00:40:15] <strong>Thiago:</strong> I guess even at your own job, if you&rsquo;re not contributing or anything, maybe there&rsquo;s a way to use those kinds of scripts to reproduce a bug. So you don&rsquo;t have, um, what is it called again, when you, you don&rsquo;t want the bug to appear again?</p><p>[00:40:31] <strong>Stefanni:</strong> Ah, regress regression. Yeah.</p><p>[00:40:32] <strong>Thiago:</strong> Regressions. Mm-hmm. You don&rsquo;t want regressions, so this is really important, so mm-hmm. Add that little test there so you don&rsquo;t have regressions. Mm-hmm. A cool habit sometimes to have. Yeah, absolutely.</p><p>[00:40:45] <strong>Stefanni:</strong> Well, I think we got to, to the end of it, so we only have 10 minutes left. Is there anything else, Nate, that you would like to share about the issue, either about the issue or about the conversation we were having?</p><p>[00:41:00] <strong>Nate Berkopec:</strong> Uh, nope. Um, I would say that, uh, if someone listening to this is interested in learning, More about working in a multi-threaded environment. Um, I do have a product called Sidekiq in Practice that has a number of live code examples that talk about thread safety and have other, it&rsquo;s a intended to be a manual, like how to actually scale Sidekiq.</p><p>[00:41:28] <strong>Nate Berkopec:</strong> And, uh, you know, cuz it&rsquo;s Sidekiq. Uh, there&rsquo;s a lot of things in there about threading and, and, um, how threads work in Sidekiq, why threads are important. It talks about the global VM lock, which we didn&rsquo;t really discuss at all today. But, uh, if, if you are looking to learn more about threads and scaling the threaded environment, um, I do, I do sell something to help you with that. So go check it out.</p><p>[00:41:51] <strong>Stefanni:</strong> Absolutely. I, it&rsquo;s in my reading list. I really need to get it. I, which one should I read first? That one or the rails? The Guide to Rails performance? I don&rsquo;t know.</p><p>[00:42:07] <strong>Nate Berkopec:</strong> Um, I mean, yeah, it just depends on what, uh, your goal is first. They&rsquo;re not, they&rsquo;re not, um, intended like. You don&rsquo;t have to read one to read the other.</p><p>[00:42:18] <strong>Nate Berkopec:</strong> So if you&rsquo;re interested in a more general perspective of how do I make a Rails app feel faster? How do I make it more scalable, like that&rsquo;s the complete guide to Rails performance. If you were specifically having issues with Sidekiq and uh, scaling Sidekiq, I suggest reading that first.</p><p>[00:42:35] <strong>Thiago:</strong> Yeah, that would be a nice episode to talk just about Sidekiq, because there are so many things to talk about. Sidekiq performance. Mm-hmm. We could do that in the future.</p><p>[00:42:46] <strong>Stefanni:</strong> Yeah. Like how to log your workers, your scheduled workers, like how to. Logging and logging and retries jobs. Yeah.</p><p>[00:42:57] <strong>Nate Berkopec:</strong> Yeah. I&rsquo;ve had a lot of fun. My, my, my current client is, um, Gusto, which is a huge, um, payroll company in the United States, and they&rsquo;ve got 600 plus engineers working on Sidekiq.</p><p>[00:43:10] <strong>Nate Berkopec:</strong> And it&rsquo;s been a really interesting experience to me to see kind of how Sidekiq scales like as an organization. So like what, what, what happens when 600 engineers all have queues and workers and like, that&rsquo;s been a whole new side of Sidekiq that I&rsquo;ve learned a lot about at, uh, at Gusto.</p><p>[00:43:27] <strong>Thiago:</strong> Yeah, it sounds really exciting work, you know, a lot of problems and, and challenges to solve, which is kinda cool.</p><p>[00:43:34] <strong>Thiago:</strong> Yeah, it&rsquo;s been really cool</p><p>[00:43:35] <strong>Stefanni:</strong> and yeah, and I think we&rsquo;re supposed to call jobs now and not workers. I&rsquo;m still getting used to the new terminology I need to catch up. I think I read something about that.</p><p>[00:43:46] <strong>Nate Berkopec:</strong> Oh, that&rsquo;s changed. I sh I feel like I should know that when I don&rsquo;t,</p><p>[00:43:48] <strong>Stefanni:</strong> I, I don&rsquo;t know. I remember seeing a comment about that, like instead of me workers, you, you like change the folder in Rails or something?</p><p>[00:43:57] <strong>Stefanni:</strong> Yeah, yeah. to jobs. No, I&rsquo;m not really sure. I have to catch up. I just remember, uh, reading about that and they&rsquo;re like, oh, I&rsquo;ll probably need to read this some at some point. Hmm. Um, yeah, so I think we. At the end, and I would like to be respectful of your time, Nate, but thank you so, so much. I learned a lot and I know it was a bit of homework for you, but I hope it was fun.</p><p>[00:44:23] <strong>Nate Berkopec:</strong> It was fun. Yeah, it was fun. It was fun. Nice to talk to you.</p><p>[00:44:27] <strong>Thiago:</strong> Yeah. Yeah. It was, it was a very specific problem with a very specific solution, so it was nice to learn from that. Mm-hmm. I&rsquo;ve learned a lot, so yeah. Thanks so much for, for sharing your expertise with us today.</p><p>[00:44:40] <strong>Nate Berkopec:</strong> Great. My pleasure</p><p>[00:44:42] <strong>Stefanni:</strong> Everyone, make sure to check out Puma and Nate&rsquo;s books, the one about Sidekiq and Rails performance.</p><p>[00:44:48] <strong>Stefanni:</strong> We&rsquo;ll leave the links in the description notes if people want to know what you&rsquo;re doing or wanna buy your books or your workshops as well. Where should they go?</p><p>[00:44:59] <strong>Nate Berkopec:</strong> Uh, speedshop.co. Uh, this is where I have links to all that stuff.</p><p>[00:45:05] <strong>Stefanni:</strong> Awesome. Cool. Cool. Thank you, Nate. Have a good weekend.</p><p>[00:45:10] <strong>Nate Berkopec:</strong> Thank you.</p><p>[00:45:11] <strong>Thiago:</strong> Thank you so much, Nate, for joining us today.</p><p>[00:45:14] <strong>Thiago:</strong> And if you&rsquo;ve learned something from this episode, please share with a friend and check out our newsletter at <a href=https://www.hexdevs.com/newsletter>www.hexdevs.com/newsletter</a>. I hope you&rsquo;ve enjoyed this episode. See you on the next one.</p><hr><p><div class=signup-form><script async data-uid=cee09b7cba src=https://hexdevs-team.ck.page/cee09b7cba/index.js></script></div><br><p>Did you like this article? You're gonna love these other ones:</p><ul><li><a href=/posts/git-checkout-upstream-branch-locally/>Fetch a Pull Request from a branch you don&rsquo;t own</a></li><li><a href=/posts/how-to-open-source-with-richard-schneeman-schneems/>How to Open Source with Richard Schneeman (@schneems)</a></li><li><a href=/posts/faker-ruby-vitor-oliveira-open-source-thursdays/>How does the Faker Ruby Gem Work?</a></li></ul></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.hexdevs.com/tags/ruby-on-rails/>Ruby on Rails</a></li><li><a href=https://www.hexdevs.com/tags/ruby/>ruby</a></li><li><a href=https://www.hexdevs.com/tags/software-development/>software development</a></li><li><a href=https://www.hexdevs.com/tags/open-source/>Open Source</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Fixing Thread Safety Bugs With Nate Berkopec on twitter" href="https://twitter.com/intent/tweet/?text=Fixing%20Thread%20Safety%20Bugs%20With%20Nate%20Berkopec&url=https%3a%2f%2fwww.hexdevs.com%2fposts%2ffixing-ruby-thread-safety-bugs-with-nate-berkopec%2f&hashtags=RubyonRails%2cRuby%2cSoftwareDevelopment%2cOpenSource"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Fixing Thread Safety Bugs With Nate Berkopec on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fwww.hexdevs.com%2fposts%2ffixing-ruby-thread-safety-bugs-with-nate-berkopec%2f&title=Fixing%20Thread%20Safety%20Bugs%20With%20Nate%20Berkopec&summary=Fixing%20Thread%20Safety%20Bugs%20With%20Nate%20Berkopec&source=https%3a%2f%2fwww.hexdevs.com%2fposts%2ffixing-ruby-thread-safety-bugs-with-nate-berkopec%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Fixing Thread Safety Bugs With Nate Berkopec on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.hexdevs.com%2fposts%2ffixing-ruby-thread-safety-bugs-with-nate-berkopec%2f&title=Fixing%20Thread%20Safety%20Bugs%20With%20Nate%20Berkopec"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Fixing Thread Safety Bugs With Nate Berkopec on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.hexdevs.com%2fposts%2ffixing-ruby-thread-safety-bugs-with-nate-berkopec%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Fixing Thread Safety Bugs With Nate Berkopec on whatsapp" href="https://api.whatsapp.com/send?text=Fixing%20Thread%20Safety%20Bugs%20With%20Nate%20Berkopec%20-%20https%3a%2f%2fwww.hexdevs.com%2fposts%2ffixing-ruby-thread-safety-bugs-with-nate-berkopec%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Fixing Thread Safety Bugs With Nate Berkopec on telegram" href="https://telegram.me/share/url?text=Fixing%20Thread%20Safety%20Bugs%20With%20Nate%20Berkopec&url=https%3a%2f%2fwww.hexdevs.com%2fposts%2ffixing-ruby-thread-safety-bugs-with-nate-berkopec%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://www.hexdevs.com/>hexdevs</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>